user: root

targets:
  dev:
    hosts:
      - {host: "46.224.129.132", name: "dev-server"}

tasks:
  - name: setup-ssh
    commands:
      - name: disable password authentication
        script: |
          sed -i 's/^#\?PasswordAuthentication.*/PasswordAuthentication no/' /etc/ssh/sshd_config
          sed -i 's/^#\?KbdInteractiveAuthentication.*/KbdInteractiveAuthentication no/' /etc/ssh/sshd_config
          systemctl reload ssh

  - name: setup-docker
    commands:
      - name: install docker
        script: |
          if docker info >/dev/null 2>&1; then
            echo "Docker already running: $(docker --version)"
            exit 0
          fi
          apt-get update
          apt-get install -y ca-certificates curl gnupg
          install -m 0755 -d /etc/apt/keyrings
          . /etc/os-release
          curl -fsSL "https://download.docker.com/linux/${ID}/gpg" -o /etc/apt/keyrings/docker.asc
          chmod a+r /etc/apt/keyrings/docker.asc
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/${ID} ${VERSION_CODENAME} stable" > /etc/apt/sources.list.d/docker.list
          apt-get update
          apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin

      - name: verify docker
        wait: {cmd: "docker info >/dev/null 2>&1", timeout: "15s", interval: "3s"}

  - name: setup-firewall
    commands:
      - name: configure ufw
        script: |
          apt-get install -y ufw
          ufw default deny incoming
          ufw default allow outgoing
          ufw allow ssh
          ufw allow http
          ufw allow https
          ufw --force enable

      - name: restrict docker external access
        script: |
          # Docker bypasses UFW by manipulating iptables directly.
          # The DOCKER-USER chain is processed before Docker's own rules.
          # Allow HTTP/HTTPS to Traefik container, block everything else.
          # Detect the default interface from the routing table.
          # Extract the value after "dev" regardless of field position
          # (output format varies with/without gateway hop).
          IFACE=$(ip -o route get 8.8.8.8 | sed -n 's/.*dev \([^ ]*\).*/\1/p')
          if [ -z "$IFACE" ]; then
            echo "ERROR: could not detect default network interface"
            exit 1
          fi
          echo "Detected default interface: $IFACE"
          # Flush and rebuild for idempotency.
          iptables -F DOCKER-USER
          iptables -A DOCKER-USER -i "$IFACE" -p tcp --dport 80 -j ACCEPT
          iptables -A DOCKER-USER -i "$IFACE" -p tcp --dport 443 -j ACCEPT
          iptables -A DOCKER-USER -i "$IFACE" -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
          iptables -A DOCKER-USER -i "$IFACE" -j DROP
          iptables -A DOCKER-USER -j RETURN
          ip6tables -F DOCKER-USER
          ip6tables -A DOCKER-USER -i "$IFACE" -p tcp --dport 80 -j ACCEPT
          ip6tables -A DOCKER-USER -i "$IFACE" -p tcp --dport 443 -j ACCEPT
          ip6tables -A DOCKER-USER -i "$IFACE" -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
          ip6tables -A DOCKER-USER -i "$IFACE" -j DROP
          ip6tables -A DOCKER-USER -j RETURN

      - name: persist docker firewall rules
        script: |
          DEBIAN_FRONTEND=noninteractive apt-get install -y iptables-persistent
          netfilter-persistent save

  - name: bootstrap
    commands:
      - name: install base packages
        script: apt-get update && apt-get install -y kitty-terminfo micro

      - name: create app directory
        script: |
          mkdir -p /opt/ronin/config /opt/ronin/www
          mkdir -p /opt/ronin/data/db/lobby /opt/ronin/data/db/game
          mkdir -p /opt/ronin/data/logs/lobby /opt/ronin/data/logs/game
          mkdir -p /opt/ronin/data/replays /opt/ronin/data/traefik
          # UID 1000 matches the 'app' user in deploy/Dockerfile
          chown -R 1000:1000 /opt/ronin/data

      - name: init env file
        copy: {src: ".env.example", dst: "/tmp/ronin-env-template"}

      - name: apply env template
        script: |
          if [ -f /opt/ronin/.env ]; then
            echo ".env already exists, skipping"
          else
            cp /tmp/ronin-env-template /opt/ronin/.env
          fi
          rm -f /tmp/ronin-env-template
          [ -f /opt/ronin/.env ] && chmod 600 /opt/ronin/.env

      - name: init system env file
        copy: {src: ".env.system.example", dst: "/tmp/ronin-env-system-template"}

      - name: apply system env template
        script: |
          if [ -f /opt/ronin/.env.system ]; then
            echo ".env.system already exists, skipping"
          else
            cp /tmp/ronin-env-system-template /opt/ronin/.env.system
          fi
          rm -f /tmp/ronin-env-system-template
          [ -f /opt/ronin/.env.system ] && chmod 600 /opt/ronin/.env.system


  - name: deploy
    commands:
      - name: upload docker-compose
        copy: {src: "docker-compose.yml", dst: "/opt/ronin/docker-compose.yml"}

      - name: upload server config
        copy: {src: "config/servers.yaml", dst: "/tmp/ronin-servers.yaml"}

      - name: upload traefik config
        copy: {src: "config/traefik-dynamic.yml", dst: "/tmp/ronin-traefik-dynamic.yml"}

      - name: render templates
        script: |
          if [ -z "$DOMAIN" ]; then
            echo "ERROR: DOMAIN variable is empty or unset"
            exit 1
          fi
          sed -i "s|%%DOMAIN%%|$DOMAIN|g" /opt/ronin/docker-compose.yml
          # Render bind-mounted configs via > to preserve inodes.
          # sed -i would create new inodes, breaking container bind mounts.
          sed "s|%%DOMAIN%%|$DOMAIN|g" /tmp/ronin-servers.yaml > /opt/ronin/config/servers.yaml
          sed "s|%%DOMAIN%%|$DOMAIN|g" /tmp/ronin-traefik-dynamic.yml > /opt/ronin/config/traefik-dynamic.yml
          rm -f /tmp/ronin-servers.yaml /tmp/ronin-traefik-dynamic.yml
          # Fail if any placeholders remain after rendering
          if grep -rq '%%DOMAIN%%' /opt/ronin/docker-compose.yml /opt/ronin/config/; then
            echo "ERROR: unrendered %%DOMAIN%% placeholders found"
            exit 1
          fi

      - name: pull image
        script: cd /opt/ronin && docker compose pull

      - name: start services
        script: cd /opt/ronin && docker compose up -d --remove-orphans

      - name: verify lobby is healthy
        wait: {cmd: "curl -sf http://localhost:8710/health", timeout: "30s", interval: "5s"}

      - name: verify game is healthy
        wait: {cmd: "curl -sf http://localhost:8711/health", timeout: "30s", interval: "5s"}

      - name: verify traefik is running
        wait: {cmd: "cd /opt/ronin && docker compose ps traefik --format json | grep -q running", timeout: "30s", interval: "5s"}

  - name: setup-restic
    commands:
      - name: install restic and sqlite3
        script: apt-get update && apt-get install -y restic sqlite3

      - name: create backup directory
        script: mkdir -p /opt/ronin/backups

      - name: init restic repo
        script: |
          if [ -d /opt/ronin/backups/keys ]; then
            echo "Restic repo already initialized, skipping"
            exit 0
          fi
          set -a
          . /opt/ronin/.env.system
          set +a
          export RESTIC_REPOSITORY=/opt/ronin/backups
          restic init

      - name: upload backup script
        copy: {src: "scripts/backup.sh", dst: "/tmp/ronin-backup.sh"}

      - name: install backup script
        script: |
          mkdir -p /opt/ronin/scripts
          cp /tmp/ronin-backup.sh /opt/ronin/scripts/backup.sh
          chmod +x /opt/ronin/scripts/backup.sh
          rm -f /tmp/ronin-backup.sh

      - name: upload restore script
        copy: {src: "scripts/restore.sh", dst: "/tmp/ronin-restore.sh"}

      - name: install restore script
        script: |
          cp /tmp/ronin-restore.sh /opt/ronin/scripts/restore.sh
          chmod +x /opt/ronin/scripts/restore.sh
          rm -f /tmp/ronin-restore.sh

      - name: upload systemd service
        copy: {src: "scripts/systemd/ronin-backup.service", dst: "/etc/systemd/system/ronin-backup.service"}

      - name: upload systemd timer
        copy: {src: "scripts/systemd/ronin-backup.timer", dst: "/etc/systemd/system/ronin-backup.timer"}

      - name: enable backup timer
        script: systemctl daemon-reload && systemctl enable --now ronin-backup.timer

  - name: backup
    commands:
      - name: run backup
        script: /opt/ronin/scripts/backup.sh

  - name: restore
    commands:
      - name: list snapshots
        script: |
          set -a
          . /opt/ronin/.env.system
          set +a
          export RESTIC_REPOSITORY=/opt/ronin/backups
          restic snapshots

      - name: restore snapshot
        script: /opt/ronin/scripts/restore.sh ${SNAPSHOT:-latest}

  - name: backup-download
    commands:
      - name: stage backup for download
        script: |
          set -eu
          STAGING="/opt/ronin/data/backup-staging"
          rm -rf "${STAGING}"
          mkdir -p "${STAGING}/db/lobby" "${STAGING}/db/game"

          LOBBY_DB="/opt/ronin/data/db/lobby/lobby.db"
          GAME_DB="/opt/ronin/data/db/game/game.db"

          if [ -f "${LOBBY_DB}" ]; then
            sqlite3 "${LOBBY_DB}" ".backup '${STAGING}/db/lobby/lobby.db'"
            echo "Staged lobby DB"
          fi

          if [ -f "${GAME_DB}" ]; then
            sqlite3 "${GAME_DB}" ".backup '${STAGING}/db/game/game.db'"
            echo "Staged game DB"
          fi

          # Ensure replays dir exists for tar (may be empty)
          mkdir -p /opt/ronin/data/replays

          tar czf "${STAGING}/backup.tar.gz" \
            -C "${STAGING}" db \
            -C /opt/ronin/data replays

          echo "Backup staged for download"

      - name: download backup archive
        copy: {src: "/opt/ronin/data/backup-staging/backup.tar.gz", dst: "/tmp/ronin-backup.tar.gz", direction: "pull"}

      - name: cleanup staging
        script: rm -rf /opt/ronin/data/backup-staging

  - name: backup-list
    commands:
      - name: list snapshots
        script: |
          set -a
          . /opt/ronin/.env.system
          set +a
          export RESTIC_REPOSITORY=/opt/ronin/backups
          restic snapshots
